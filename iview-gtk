#!/usr/bin/python2

import iview.config
import iview.comm
import iview.fetch
import gtk
import gobject
import threading
import sys
import re
import urllib2

cr = '\015' # carriage return
num_windows = 0

def add_window():
	global num_windows
	num_windows += 1

def del_window(widget=None):
	global num_windows
	num_windows -= 1
	if num_windows == 0:
		gtk.main_quit()

def readupto(fh, upto):
	"""	Reads up to (and not including) the character
		specified by arg 'upto'.
	"""
	result = ''
	while True:
		char = fh.read(1)
		if char == '' or char == upto:
			return result
		else:
			result = ''.join((result,char))

class DownloadWorker(threading.Thread):
	def __init__(self, parent):
		threading.Thread.__init__(self)
		self.parent = parent

	def run(self):
		progress_pattern = re.compile(r'\d+\.\d%')
		size_pattern = re.compile(r'\d+\.\d+ kB', re.IGNORECASE)

		rate = 0
		self.parent.progress.set_text('')

		while True:
			r = readupto(self.parent.job.stderr, cr)
			if r == '': # i.e. EOF, the process has quit
				break
			progress_search = progress_pattern.search(r)
			size_search = size_pattern.search(r)
			if progress_search is not None:
				p = float(progress_search.group()[:-1]) / 100. # [:-1] shaves the % off the end
				gtk.gdk.threads_enter()
				self.parent.progress.set_fraction(p)
				self.parent.set_title("(%0.1f%%) %s" %(p*100, self.parent.my_title))
				gtk.gdk.threads_leave()
			if size_search is not None:
				gtk.gdk.threads_enter()
				self.parent.labels[2][1] \
					.set_text('%.1f' % (float(size_search.group()[:-3]) / 1024.) + ' MB')
				gtk.gdk.threads_leave()
			if progress_search is None and size_search is None:
				print 'Backend debug:\t' + r

		returncode = self.parent.job.wait()

		gtk.gdk.threads_enter()

		if returncode == 0: # EXIT_SUCCESS
			self.parent.progress.set_fraction(1.)
			self.parent.progress.set_text('Download finished')
			self.parent.set_title(self.parent.my_title)
			self.parent.close_btn.set_label(gtk.STOCK_CLOSE)
			self.parent.pause_btn.hide()
			self.parent.resume_btn.hide()
		else:
			print 'Backend aborted with code %d (either it crashed, or you paused it)' % returncode
			if returncode == 1: # connection timeout results in code 1
				self.parent.progress.set_text('Download failed')
			self.parent.pause_btn.hide()
			self.parent.resume_btn.show()

		gtk.gdk.threads_leave()

class Downloader(gtk.Window):
	def __init__(self, url, title=None, dest_file=None):
		self.url = url
		self.dest_file = dest_file

		gtk.Window.__init__(self)
		self.connect('destroy', del_window)
		self.connect('destroy', self.on_destroy)
		add_window()

		if title is None:
			title = url
		self.my_title = dest_file.split("/")[-1]
		self.set_title(title)
		self.set_resizable(False)
		self.set_default_size(400,0)
		self.set_border_width(10)

		xpadding = 5
		ypadding = 2

		table = gtk.Table(3, 3, homogeneous=False)

		self.labels = []
		for i in range(3):
			label_term = gtk.Label()
			label_term.set_alignment(0., 0.5)
			label_desc = gtk.Label()
			label_desc.set_alignment(1., 0.5)
			self.labels.append([label_term, label_desc])

			table.attach(label_term, 0,1, i,i+1, xpadding=xpadding, ypadding=ypadding)
			table.attach(label_desc, 1,2, i,i+1, xpadding=xpadding, ypadding=ypadding)

		self.labels[0][0].set_text('Name')
		self.labels[0][1].set_text(title)
		self.labels[1][0].set_text('Filename')
		self.labels[1][1].set_text(dest_file.split('/')[-1])
		self.labels[2][0].set_text('Download size')
		self.labels[2][1].set_text('0.0 MB')

		self.progress = gtk.ProgressBar()
		table.attach(self.progress, 0,2, 3,4, xpadding=xpadding, ypadding=8)

		bb = gtk.HButtonBox()
		bb.set_layout(gtk.BUTTONBOX_END)
		self.pause_btn = gtk.Button('Pause')
		self.pause_btn.connect('clicked', self.pause_download)
		self.resume_btn = gtk.Button('Resume')
		self.resume_btn.connect('clicked', self.start_download)
		self.close_btn = gtk.Button(stock=gtk.STOCK_STOP)
		self.close_btn.connect('clicked', self.destroy)
		bb.pack_end(self.pause_btn)
		bb.pack_end(self.resume_btn)
		bb.pack_end(self.close_btn)

		vbox = gtk.VBox()
		vbox.pack_start(table)
		vbox.pack_start(bb, expand=False)
		self.add(vbox)

		self.show_all()
		self.start_download() # kick off the DownloadWorker thread

	def start_download(self, widget=None):
		self.resume_btn.hide()
		self.pause_btn.show()

		self.job = iview.fetch.fetch_program(self.url, dest_file=self.dest_file)

		if not self.job:
			message = gtk.MessageDialog(
				parent=None,
				type=gtk.MESSAGE_ERROR,
				buttons=gtk.BUTTONS_CLOSE)
			message.set_markup('<big><b>Download backend failed</b></big>\n\n' \
				'Either the download backend in question failed for some reason, or one could not be found with which to download iView programmes. Please check the README file for instructions on setting this up.')
			message.run()
			message.destroy()
			return

		self.download_worker = DownloadWorker(self).start()

	def pause_download(self, widget=None):
		self.job.terminate()
		self.pause_btn.hide()
		self.resume_btn.show()

	def on_destroy(self, widget=None):
		try:
			self.job.terminate()
		except OSError: # this would trigger if it was
			pass        # already killed for some reason

	def destroy(self, null_param=None):
		"""	Allow destroy() to be called with a parameter, thus allowing it to
			be attached to the "clicked" event of a button.
		"""
		gtk.Window.destroy(self)

def on_download_clicked(widget, data=None):
	global window, save_location

	model, selected_iter = listing.get_selection().get_selected()
	if selected_iter is None:
		return
	item = model.get(selected_iter, 0, 2)
	if item[1] is None:
		return

	save_dialog = gtk.FileChooserDialog('Save Video',
		parent=window,
		action=gtk.FILE_CHOOSER_ACTION_SAVE,
		buttons=(gtk.STOCK_CANCEL, gtk.RESPONSE_CANCEL,
		         gtk.STOCK_SAVE, gtk.RESPONSE_OK))

	try:
		save_dialog.set_current_folder(save_location)
	except NameError: # if we haven't set a save_location yet
		pass
	
	# build a nice filename
	program = model.get(model.iter_parent(selected_iter), 0, 1)[0]
	title = item[0]
	ext = item[1].split(".")[-1]
	# for specials that title == program, just use program.ext
	if program == title:
		filename = "%s.%s" %(program, ext)
	else:
		filename = "%s - %s.%s" %(program, title, ext)
	# strip invalid filename characters < > : " / \ | ? *
	filename = re.sub('[\<\>\:\"\/\\\|\?\*]', '-', filename)
	save_dialog.set_current_name(filename)
	#save_dialog.set_current_name(iview.fetch.get_filename(item[1]))
	save_dialog.set_local_only(False) # allow saving to, e.g., SFTP
	save_response = save_dialog.run()
	save_dialog.hide()

	if save_response == gtk.RESPONSE_OK:
		dest_file = save_dialog.get_filename()
		save_location = save_dialog.get_current_folder()
		Downloader(item[1], item[0], dest_file)

	save_dialog.destroy()

def on_listing_cursor_changed(widget):
	global description

	description.set_text('')
	download_btn.set_sensitive(False)

	model, selected_iter = listing.get_selection().get_selected()
	if selected_iter is None:
		return
	item = model.get(selected_iter, 0, 2, 3)
	if item[1] is None or item[2] is None:
		return

	description.set_text(item[2])
	download_btn.set_sensitive(True)

def load_programme():
	global programme

	for series in iview.comm.get_index():
		series_iter = programme.append(None, [series['title'], series['id'], None, None])
		programme.append(series_iter, ['Loading...', None, None, None])

def load_series_items(widget, iter, path):
	model = widget.get_model()
	child = model.iter_children(iter)

	if model.get(child, 2)[0] is not None:
		# This is not a "Loading..." item, so we've already fetched this.
		# Better pull out.
		return

	series_id = model.get(iter, 1)[0]
	items = iview.comm.get_series_items(series_id)

	for item in items:
		model.append(iter, [
				item['title'],
				None,
				item['url'],
				item['description'],
			])

	model.remove(child)

def about(widget, data=None):
	d = gtk.AboutDialog()

	d.set_version(iview.config.version)
	d.set_copyright('Copyright \302\251 2009-2010 by Jeremy Visser')
	d.set_license("""This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.""")

	d.run()
	d.destroy()

gtk.gdk.threads_init()

window = gtk.Window()
window.set_title('iView')
window.set_default_size(400,450)
window.set_border_width(5)
window.connect('destroy', del_window)
add_window()

vbox = gtk.VBox()

programme_label = gtk.Label()
programme_label.set_markup('<big><b>iView Programme</b></big>')

vbox.pack_start(programme_label, expand=False)

listing_scroller = gtk.ScrolledWindow()
listing_scroller.set_policy(gtk.POLICY_AUTOMATIC, gtk.POLICY_AUTOMATIC)
listing_scroller.set_shadow_type(gtk.SHADOW_IN)

# name, id, url, description
programme = gtk.TreeStore(str, str, str, str)

listing = gtk.TreeView(programme)
listing.set_headers_visible(False)
listing.get_selection().set_mode(gtk.SELECTION_SINGLE)
listing.connect('cursor-changed', on_listing_cursor_changed)
listing.connect('row-expanded', load_series_items)

tvcolumn = gtk.TreeViewColumn('Program Name')
listing.append_column(tvcolumn)
cell = gtk.CellRendererText()
tvcolumn.pack_start(cell, True)
tvcolumn.add_attribute(cell, 'text', 0)

listing_scroller.set_border_width(5)

listing_scroller.add(listing)
vbox.pack_start(listing_scroller)

description = gtk.Label()
description.set_line_wrap(True)
vbox.pack_start(description, expand=False)

bb = gtk.HButtonBox()
bb.set_layout(gtk.BUTTONBOX_EDGE)
bb.set_border_width(5)

about_btn = gtk.Button(stock=gtk.STOCK_ABOUT)
about_btn.connect('clicked', about)
download_btn = gtk.Button('Download')
download_btn.set_sensitive(False)
download_btn.connect('clicked', on_download_clicked)

bb.pack_start(about_btn)
bb.pack_start(download_btn)

vbox.pack_start(bb, expand=False)

window.add(vbox)

try:
	if sys.argv[1] in ('-c', '--cache'):
		iview.comm.cache = True
except IndexError:
	pass

try:
	iview.comm.get_config()
	load_programme()
except urllib2.HTTPError, error:
	message = gtk.MessageDialog(
		parent=window,
		type=gtk.MESSAGE_ERROR,
		buttons=gtk.BUTTONS_CLOSE)
	message.set_markup('<big><b>Download failed</b></big>\n\n' \
		'Could not retrieve an important configuration file from iView.' \
		' Please make sure you are connected to the Internet.\n\n' \
		'If iView works fine in your web browser, then the iView API' \
		' has most likely changed. Try and find an updated version of this'
		' program, or contact the author.\n\n' \
		'URL: %s' % error.url)
	message.run()
	gtk.main_quit()
	sys.exit(1)

window.show_all()
gtk.main()
